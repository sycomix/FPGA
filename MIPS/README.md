> https://inst.eecs.berkeley.edu/~cs61c/resources/MIPS_Green_Sheet.pdf
# MIPS
| Имя регистра     | Номер    | Двоичный индекс |
| -----------------|----------|-----------------|
|$0          |0            |00000|
|$at         |1            |00001|
|$v0         |2            |00010|
|$v1         |3            |00011|
|$a0         |4            |00100|
|$a1         |5            |00101|
|$a2         |6            |00110|
|$a3         |7            |00111|
|$t0         |8            |01000|
|$t1         |9            |01001|
|$t2         |10           |01010|
|$t3         |11           |01011|
|$t4         |12           |01100|
|$t5         |13           |01101|
|$t6         |14           |01110|
|$t7         |15           |01111|
|$s0         |16           |10000|
|$s1         |17           |10001|
|$s2         |18           |10010|
|$s3         |19           |10011|
|$s4         |20           |10100|
|$s5         |21           |10101|
|$s6         |22           |10110|
|$s7         |23           |10111|
|$t8         |24           |11000|
|$t9         |25           |11001|
|$k0         |26           |11010|
|$k1         |27           |11011|
|$gp         |28           |11100|
|$sp         |29           |11101|
|$fp         |30           |11110|
|$ra         |31           |11111|


# Команда типа R-type (register type)
> add rd, rs, rt



Берем значения из регистров rs и rt, вычислим сумму и запишим результат в регистр rd.
В качестве трех оперндов выступают адреса регистров.


Рассмотрим на примере машинного кода.


Процессор 32-х битный, следовательно на каждую команд отводится по 32 бита. 


> [**op**(6 бит)][**rs** (5 бит)][**rt** (5 бит)][**rd** (5 бит)][**shamt** (5 бит)][**funct** (6 бит)]


- **op**+**funct** = операция
- **op** (opcode) = 0 для всех операций R-type
- **funct** (function): для add=32, для sub=34
- **rs, rt, rd** - операнды - адреса регистров ('r' везде от register)
- **rs, rt** - источник1, источник2 (обозначение выбрано как s - source, а 't' просто идет в алфавите после 's')
- **rd** - назначение (destination)
- **shamt** - сдвиг (ammount of shift) = 0 для всех операций R-type

Рассмотрим пример команды:

> add $s0, $s1, $s2

add имеет op = 00000 (0), funct = 100000 (32), rd (registr destination ) = 10000 (16), rs (registr source) = 10001, rt (registr source) = 10010, shamt = 00000 (0)

Итог:

> 00000_10001_10010_10000_00000_100000


> op_rs_rt_rd_shamt_funct

# Команды типа I-type (immediate type)
> lw rt, imm (rs)

lw (load word - загрузить слово) загружает значение из памяти данных в регистр.

- **rt** - адрес регистра-назначения
- **imm** - константа - адрес загружаемого значения в памяти данных
- **rs** - адрес регистра, содержащего значение сдвига для адреса загрузки

sw (store word - сохранить слово) записывает (сохраняет) значение из регистра в память данных.

> sw rt, imm (rs)


- **rt** - адрес регистра-источника
- **imm** - константа - адрес сохранения значения в памяти данных
- **rs** - адрес регистра, содержащего значение сдвига для адреса сохранения

addi (add immediate - сложить с константой) складывает значение регистра с константой и записывает результат в регистр.

> addi rt, rs, imm

- **rt** - адрес регистра-назначения
- **rs** - адрес регистра, содержащего 1е складываемое значение
- **imm** - константа - 2е складываемое значение

beq (branch if equal - ответвиться, если равно) осуществляет условный переход - перевод счетчика программы в указанное место при выполнении определенного условия.

> beq rs, rt, imm

- **rs, rt** - адреса регистров, значения которых сравнивает команда
- **imm** - адрес перехода относительно адреса текущей инструкции (в ассемблерной программе задается при помощи специальных меток)

> [ **op** (6 бит) ][ **rs** (5 бит) ][ **rt** (5 бит) ][ **imm** (16 бит) ]


- **op** - код операции: для lw=35, для sw=43, для addi=8, для beq=4
- **rs, rt** - адреса регистров-операндов - смысловые роли могут быть разные для разных команд
- **imm (immediate)** - значение операнда-константы

# Выполнение простой программы
Загрузить из памяти два числа, сложить их и загрузить результат обратно в память.
Для реализации нашего процессора на начальном этапе будет достаточно набор следующих команд:
1. add (сложение) - Binary -> 100000 :: R-type
2. sub (вычитание) - Binary -> 100010 :: R-type
3. lw (загрузка значения из памяти данных) - Binary -> 100011 :: I-type
4. sw (сохранение значения в память данных) - Binary -> 101011 :: I-type
5. addi (сложение с константой) - Binary -> 001000 :: I-type
6. beq (условный переход) - Binary -> 000100 :: I-type
7. j (безусловный переход) - Binary -> 000010 :: J-type

[!!!] ADD
R[rd] = R[rs] + R[rt] 
add $s0, $s1, $s2 - складываем два регистра
$s0=$s1+$s2
[ op (6 бит) ][ rs (5 бит) ][ rt (5 бит) ][ rd (5 бит) ][ shamt (5 бит) ][ funct (6 бит) ]
op - opcode - 6 бит - 6'000_000
rs - 'r' - регистр - (источник) - $s1 - 5'b10001
rt - (источник) - $s2 - 5b'10010
rd - (назначение) - $s0 - 10000
shamt - сдвиг - 5'b00000
funct - функция, для add - 6'b100000
Получаем машинную команду сложение двух регистров
32'b000000_10001_10010_10000_00000_100000

[!!!] SUB
add $s0, $s1, $s2 - вычитаем два регистра
Все тоже самое, только меняться funct, для SUB - 6'b100010
Получаем машинную команду вычитание двух регистров
32'b000000_10001_10010_10000_00000_100010

[!!!] ADDI -> Add Immediate
R[rt] = R[rs] + SignExtImm
addi rt, rs, imm складывает значение регистра с константой и записывает результат в регистр
addi $s0, $s1, 4
[ op (6 бит) ][ rs (5 бит) ][ rt (5 бит) ][ imm (16 бит) ]
op - код операции, для addi - 6'b001000
rs - 'r' - регистр - (источник) - $s0 - 5'10000
rt - 5'b00000
imm число
Получаем машинную команду вычитание двух регистров
32'b001000_10000_00000_0000000000000100 // 4